# Objects

TS can also infer object shape.

```ts
const dog = {
  name: "Elton",
  type: "Australian Shepherd",
  age: 0.5,
};

dog.name = 4; //Type 'number' is not assignable to type 'string'
```

## Objects as function params

You can pass objects as function params that TS will detect

```ts
function printName(person: { first: string; last: string }): string {
  return `${person.first} ${person.last} says hello`;
}

printName({ first: "thomas", last: "rolfe" });
```

### Excess properties and a TS quirk

If we take the above function and add an additional object property as a param TS will yell at us:

```ts
printName({ first: "thomas", last: "rolfe", age: 32 }); // Object literal may only specify known properties, and 'age' does not exist in type '{ first: string; last: string; }'.
```

This makes sense, but if we define a new object outside of the function and print it:

```ts
const singer = { first: "mick", last: "jagger", age: 100 };
printName(singer);
```

> We don't get an error. This is just a quirk of TS. Defining the object inline in the function params will throw an error if you add excess properties, if you define it outside, it won't.

## Objects as function returns

You can declare objects as function returns like so:

```ts
function returnCoords(): { x: number; y: number } {
  return {
    x: Math.random(),
    y: Math.random(),
  };
}
```

## Defining objects inline

This is uncommon, but you can define objects inline like:

```ts
const myCoordsInline: { x: number; y: number } = { x: 20.6555, y: 8.2224 };
```

## Type Alias

Instead of writing out object types in an annotation, we can declare them separately in a _type alias_, which is simply the desired shape of the object.

This helps with code readability and re-usability.

Say we have a coordinates object that stores an `x` and a `y` number, we can define as a type alias:

```ts
type Point = {
  x: number;
  y: number;
};
```

We can then use `Point` throughout our code.

When defining an object:

```ts
const coordinates: Point = { x: 55, y: 0.2 };
```

As function params:

```ts
const multiplyPoint = (point: Point) => {
  return {
    xCord: point.x * 2,
    yCord: point.y * 10,
  };
};
```

And as function returns:

```ts
const doubleCoords = (point: Point): Point => {
  return {
    x: point.x * 2,
    y: point.y * 2,
  };
}; // function declaration

doubleCoords({ x: 20, y: 2 }); // function call = { x: 40, y: 10 }
```

# Nested Objects

Nesting objects is simple and a very common thing to do, you just provide the nested object as another key in the object declaration:

```ts
// Type declaration
type Person = {
  name: string;
  age: number;
  location: {
    city: string;
    country: string;
  };
};

// Variable declaration
const newPerson: Person = {
  name: "Jeremy",
  age: 35,
  location: {
    city: "Sydney",
    country: "Australia",
  },
};
```

‚òùüèªthat's the verbose version, of course TS can just infer the type as well:

```ts
const newPerson = {
  name: "Jeremy",
  age: 35,
  location: {
    city: "Sydney",
    country: "Australia",
  },
};
```

## Passing nested objects to functions

It's easy to pass this object declaration to functions:

```ts
function ageInDogYears(person: Person): number {
  return newPerson.age * 9;
}

ageInDogYears(newPerson);
```

Note that person here is just any param that you would usually declare as a function argument.

## Optional object properties 'prop?'

You can make certain object properties optional using `?`, for example:

```ts
type Point = {
  x: number;
  y: number;
  z?: number;
};

const myPoint: Point = {
  x: 6,
  y: 10,
}; // This is a valid declaration even though z is missing
```

## readonly modifier

The `readonly` modifier allows you to set an object property as readonly. You can assign an initial value, but after that you won't be able to reassign:

```ts
type User = {
  readonly id: number;
  userName: string;
};

const user: User = {
  id: 1847,
  userName: "Batman",
};

console.log(user.id); // All good
user.id = 666; // This will ERROR
```

## Intersection types (ampersand &)

You can combine objects into a larger object using the `&`:

```ts
type Circle = {
  radius: number;
};

type Colourful = {
  color: string;
};

type ColourfulCircle = Circle & Colourful;

const happyFace: ColourfulCircle = {
  radius: 4,
  color: "Yellow",
};
```

You can also set this inline like so:

```ts
type SmileyFace = Circle &
  Colourful & {
    eyes: number;
  };

const theSmile: SmileyFace = {
  radius: 5,
  color: "red",
  eyes: 2,
};

console.log(theSmile);
```
