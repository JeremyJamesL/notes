# Union Types

Union types allow us to give a value a few different possible types.

Union Types are created by a pipe `|` that separates the types we want

```ts
const age: number | string = "23"; // We initialise age with an age string
age = 23; // We can change it to a number
```

The above example shows that TS will allow us to define both a number and a string to this variable because we have defined both as valid types for the variable.

## Type narrowing with union types

Type narrowing refers to helping Typescript know which type it is currently working with, TS is then smart enough to not throw errors in certain cases.

This is helpful with union types, where there are multiple types that TS could be working with.

For e.g:

```ts
function calculateTax(price: number | string, tax: number):  {
    if(typeof price === "string") {
        return price.replace("$", "")
    } else {
        return price * tax
    }
}

calculateTax(24, 0.7);
calculateTax("$24", 0.7);
```

Here, price can be both a `number` or a `string`, the `if...else` block allows TS to know where in our function we are using `strings` or `numbers`, if we didn't define the `if...else` block it would throw an error saying we can't make a string operation on a number, for example

## Union Types and Arrays

Union types are compatible with `Arrays`. This allows us to specify what types are valid in any one array. We achieve this with parenthesis notation.

For example:

```ts
const numsAndString: (number | string)[] = [1, 2, 3, "4", "5"];
```

If we then added a `boolean` to the above, it would throw an error.

An example using type definitions:

```ts
type Point = {
  x: number;
  y: number;
};

type Coords = {
  lat: string;
  lon: string;
};

const pointsAndCoordsArr: (Point | Coords)[] = [
  { x: 12, y: -20 },
  { lat: "1.232432", lon: "326.5454" },
];
```

## Literal types

Literal types tell TS that a variable _has_ to be a certain value.

For example:

```ts
let zero: 0 = 0;
zero = 1; // Will throw an error
```

We are saying the `variable` has to be the value 0 and it can never change.

This isn't that useful, but when we combine with union types, it helps because we can define a set of options:

```ts
type Day = "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday";
let today: Day = "Monday"; // Will be fine
let today: Day = "Mon"; // Will throw an error
```

> Literal types aren't very useful on their own, but combining literal types with union types is quite useful by defining a list of options
